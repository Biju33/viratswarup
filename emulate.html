<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VIRAT SWARUP</title>
    <!-- Font Awesome Icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      /* Reset & Base Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Georgia", serif;
      }

      body {
        background: #ffffff;
        color: #2c2c2c;
      }

      /* हैडर सेक्शन */
      .header {
        padding: 95px 20px 45px;
        text-align: center;
        border-bottom: 1px solid #e0e0e0;
        background-color: #8b0000;
      }
      .header h1 {
        font-size: 52px;
        letter-spacing: 3.2px;
        text-transform: uppercase;
        margin-bottom: 12px;
        color: white;
      }
      .header h2 {
        font-size: 22px;
        color: #fff;
        font-weight: 300;
      }

      /* हैमबर्गर मेन्यू */
      .hamburger {
        position: fixed;
        top: 25px;
        right: 25px;
        cursor: pointer;
        display: none;
        z-index: 1000;
      }
      .hamburger-line {
        width: 28px;
        height: 2px;
        background: #000000;
        margin: 6px 0;
        transition: 0.4s;
      }

      /* मोबाइल मेन्यू */
      .mobile-menu {
        position: fixed;
        top: 0;
        right: -300px;
        width: 300px;
        height: 100%;
        background: #8b0000;
        box-shadow: -2px 0 15px rgba(0, 0, 0, 0.1);
        transition: 0.4s;
        padding-top: 80px;
        z-index: 999;
      }
      .mobile-menu.active {
        right: 0;
      }
      .mobile-menu a {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 18px 30px;
        color: #fff;
        text-decoration: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .mobile-menu i {
        width: 25px;
        font-size: 20px;
        color: #fff;
      }

      /* बॉटम नेविगेशन */
      .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: #8b0000;
        border-top: 1px solid #eee;
        padding: 8px 0;
        display: none;
        z-index: 999;
      }
      .bottom-nav ul {
        display: flex;
        justify-content: space-around;
        list-style: none;
      }
      .bottom-nav a {
        color: #fff;
        font-size: 16px;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 10px 14px;
        border-radius: 8px;
        transition: background 0.3s;
      }

      .bottom-nav a:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }

      /* डेस्कटॉप नेविगेशन */
      .desktop-nav {
        margin: 45px 0;
      }
      .desktop-nav ul {
        display: flex;
        justify-content: center;
        gap: 32px;
        list-style: none;
      }
      .desktop-nav a {
        color: #8b0000;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 18px;
      }

      /* रिस्पॉन्सिव डिज़ाइन */
      @media (max-width: 768px) {
        .hamburger {
          display: block;
        }
        .desktop-nav {
          display: none;
        }
        .bottom-nav {
          display: block;
        }
        .header {
          padding: 70px 20px 35px;
        }
        .header h1 {
          font-size: 42px;
        }
      }
    </style>
  </head>
  <body>
    <!-- हैमबर्गर आइकन -->
    <div class="hamburger" onclick="toggleMenu()">
      <div class="hamburger-line"></div>
      <div class="hamburger-line"></div>
      <div class="hamburger-line"></div>
    </div>

    <!-- मोबाइल मेन्यू -->
    <nav class="mobile-menu">
      <a href="#login"><i class="fas fa-sign-in-alt"></i>Login</a>
      <a href="#share"><i class="fas fa-share"></i>Share</a>
      <a href="index.html"><i class="fas fa-home"></i>Home</a>
      <a href="agnosia.html"><i class="fas fa-eye-slash"></i>Agnosia</a>
      <a href="enigma.html"><i class="fas fa-question-circle"></i>Enigma</a>
      <a href="emulate.html"><i class="fas fa-copy"></i>Emulate</a>
      <a href="index.html"><i class="fas fa-comment"></i>Post</a>
    </nav>

    <!-- हैडर -->
    <header style="background-color: #8b0000; padding: 10px 10px 10px; text-align: center;">

  <h1 style="color: white; font-size: 24px 16; margin: 0;">VIRAT SWARUP</h1>
  <h2 style="color: white; font-size: 13px; margin: 0;"> The Supreme Devine of Every Faith</h2>

    </header>

    <!-- डेस्कटॉप नेविगेशन -->
    <nav class="desktop-nav">
      <ul>
        <li><a href="index.html"><i class="fas fa-home"></i>Home</a></li>
        <li><a href="#agnosia.html"><i class="fas fa-eye-slash"></i>Agnosia</a></li>
        <li><a href="#enigma.html"><i class="fas fa-question-circle"></i>Enigma</a></li>
        <li><a href="#emulate.html"><i class="fas fa-copy"></i>Emulate</a></li>
        <li><a href="index.html"><i class="fas fa-comment"></i>Post</a></li>
      </ul>
    </nav>

    <!-- बॉटम नेविगेशन -->
    <nav class="bottom-nav">
      <ul>
        <li><a href="index.html"><i class="fas fa-home"></i>Home</a></li>
        <li><a href="agnosia.html"><i class="fas fa-eye-slash"></i>Agnosia</a></li>
        <li><a href="enigma.html"><i class="fas fa-question-circle"></i>Enigma</a></li>
        <li><a href="emulate.html"><i class="fas fa-copy"></i>Emulate</a></li>
        <li><a href="index.html"><i class="fas fa-comment"></i>Post</a></li>
      </ul>
    </nav>

<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>EvoRun: Cell to Cosmos (Endless)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #fff;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden; /* Prevent scrollbars from canvas */
        }
        #gameContainer {
            position: relative;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
        }
        canvas {
            display: block;
            background-color: #000; /* Fallback, will be drawn over */
        }
        #uiOverlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none; /* Allow clicks to pass through to canvas */
        }
        #score, #stageName {
            font-size: 9px;
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #progressBarContainer {
            width: 100%;
            background-color: #fff;
            border-radius: 5px;
            overflow: hidden;
            height: 20px;
            margin: 10px 0;
            border: 1px solid #fff;
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #8b0000;
            transition: width 0.3s ease-in-out;
        }
        #controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            font-size: 16px;
            background-color: #8b0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        button:hover {
            background-color: #8b0000;
        }
        #startScreen, #stageCompleteScreen { /* Removed #gameWonScreen style */
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }
        #startScreen h2, #stageCompleteScreen h2 { margin-top: 0; }
        #startScreen p, #stageCompleteScreen p { margin-bottom: 20px; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="uiOverlay">
            <div id="stageName">Cell</div>
            <div id="score">Score: 0</div>
        </div>
        <div id="startScreen">
            <h2>Cell to Cosmos</h2>     
            <p>The final stage is endless. Reach for the highest score!</p>
            <button id="startButton">Start Game</button>
        </div>
        <div id="stageCompleteScreen" style="display: none;">
            <h2 id="stageCompleteTitle">Stage Complete!</h2>
            <p id="stageCompleteMessage">Preparing for the next phase of evolution...</p>
            <button id="nextStageButton">Next Stage</button>
        </div>
         <!-- Removed gameWonScreen div -->
    </div>
    <div id="progressBarContainer">
        <div id="progressBar"></div>
    </div>
    <div id="controls">
        <button id="musicToggle">Music: OFF</button>
        <button id="sfxToggle">SFX: ON</button>
        <button id="restartGameButton" title="Restart Game">Restart</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const stageNameDisplay = document.getElementById('stageName');
        const progressBar = document.getElementById('progressBar');

        const startScreen = document.getElementById('startScreen');
        const stageCompleteScreen = document.getElementById('stageCompleteScreen');
        // const gameWonScreen = document.getElementById('gameWonScreen'); // Removed
        const stageCompleteTitle = document.getElementById('stageCompleteTitle');
        const stageCompleteMessage = document.getElementById('stageCompleteMessage');
        // const finalScoreDisplay = document.getElementById('finalScore'); // Removed
        
        const startButton = document.getElementById('startButton');
        const nextStageButton = document.getElementById('nextStageButton');
        const restartGameButton = document.getElementById('restartGameButton');
        const musicToggleButton = document.getElementById('musicToggle');
        const sfxToggleButton = document.getElementById('sfxToggle');

        let gameWidth, gameHeight;
        let player;
        let collectibles = [];
        let obstacles = [];
        let score = 0;
        let currentStageIndex = 0;
        let stageProgress = 0;
        let gameSpeed = 2;
        let animationFrameId;
        let isGameRunning = false;
        let isJumping = false;
        let isInEndlessMode = false; // New flag

        let sfxOn = true;
        let musicOn = false;

        let audioCtx;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn("Web Audio API is not supported. SFX disabled.");
            sfxOn = false;
            sfxToggleButton.textContent = "SFX: N/A";
            sfxToggleButton.disabled = true;
        }

        function playSound(type = 'collect') {
            if (!sfxOn || !audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'collect') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
            } else if (type === 'stage_complete') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(261.63, audioCtx.currentTime); // C4
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.8);
            }
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + (type === 'collect' ? 0.2 : 0.8));
        }
        
        const STAGES = [
            {
                name: "Cell",
                bgColor: "#001f3f", playerColor: "#7FDBFF", playerRadius: 15,
                collectibleColor: "#FFDC00", collectibleRadius: 8, collectibleValue: 10,
                goal: 100, itemSpawnRate: 100,
                playerRepresentation: (p) => {
                    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    const pulse = Math.sin(Date.now() * 0.01) * 2;
                    ctx.strokeStyle = `rgba(127, 219, 255, ${0.5 + Math.sin(Date.now() * 0.01)*0.5})`;
                    ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + pulse, 0, Math.PI * 2); ctx.stroke();
                },
                collectibleRepresentation: (c) => {
                    ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill();
                }
            },
            {
                name: "Heart",
                bgColor: "#600000", playerColor: "#FF4136", playerRadius: 20,
                collectibleColor: "#FF851B", collectibleRadius: 10, collectibleValue: 15,
                goal: 150, itemSpawnRate: 80,
                playerRepresentation: (p) => {
                    ctx.fillStyle = p.color; const pulse = Math.sin(Date.now() * 0.02) * 5;
                    const w = (p.radius + pulse) * 2; const h = w * 0.9;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y + h / 4);
                    ctx.bezierCurveTo(p.x, p.y, p.x - w / 2, p.y, p.x - w / 2, p.y + h / 4);
                    ctx.bezierCurveTo(p.x - w / 2, p.y + h / 2, p.x, p.y + h / 1.5, p.x, p.y + h);
                    ctx.bezierCurveTo(p.x, p.y + h / 1.5, p.x + w / 2, p.y + h / 2, p.x + w / 2, p.y + h / 4);
                    ctx.bezierCurveTo(p.x + w / 2, p.y, p.x, p.y, p.x, p.y + h / 4); ctx.fill();
                },
                collectibleRepresentation: (c) => {
                    ctx.fillStyle = c.color; const pulse = Math.sin(Date.now() * 0.015 + c.x) * 2;
                    ctx.beginPath(); ctx.arc(c.x, c.y, c.radius + pulse, 0, Math.PI * 2); ctx.fill();
                }
            },
            {
                name: "Earth",
                bgColor: "#003366", playerColor: "#3D9970", playerRadius: 25,
                collectibleColor: "#0074D9", collectibleRadius: 12, collectibleValue: 20,
                goal: 200, itemSpawnRate: 120,
                playerRepresentation: (p) => {
                    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "#7FDBFF"; ctx.beginPath();
                    ctx.arc(p.x + p.radius*0.2, p.y - p.radius*0.3, p.radius*0.7, Math.PI*0.3, Math.PI*1.2); ctx.fill();
                    ctx.beginPath(); ctx.arc(p.x - p.radius*0.3, p.y + p.radius*0.1, p.radius*0.5, Math.PI*1.5, Math.PI*0.5); ctx.fill();
                },
                collectibleRepresentation: (c) => {
                    ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "rgba(173, 216, 230, 0.5)"; ctx.beginPath();
                    ctx.moveTo(c.x + c.radius, c.y); ctx.lineTo(c.x + c.radius + 20, c.y - 5);
                    ctx.lineTo(c.x + c.radius + 20, c.y + 5); ctx.closePath(); ctx.fill();
                }
            },
            { // New Universe stage - will become endless
                name: "Universe",
                bgColor: "#0c0014", // Very dark purple/black
                playerColor: "#f0f0f0", // Bright point of light / cosmic spark
                playerRadius: 10, // Smaller, more ethereal
                collectibleColor: "#dda0dd", // Plum / light purple (Dark Matter Filaments)
                collectibleRadius: 7,
                collectibleValue: 25,
                goal: 250, // Initial goal before becoming endless
                itemSpawnRate: 90,
                playerRepresentation: (p) => { // Pulsing star/spark
                    ctx.fillStyle = p.color;
                    const corePulse = Math.sin(Date.now() * 0.03) * (p.radius * 0.3);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * 0.7 + corePulse, 0, Math.PI * 2);
                    ctx.fill();
                    // Outer glow
                    const glowPulse = Math.sin(Date.now() * 0.02) * 5;
                    const gradient = ctx.createRadialGradient(p.x, p.y, p.radius * 0.5, p.x, p.y, p.radius + glowPulse + 5);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.sin(Date.now() * 0.025) * 0.2})`);
                    gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius + glowPulse + 5, 0, Math.PI * 2);
                    ctx.fill();
                },
                collectibleRepresentation: (c) => { // Wispy strands
                    ctx.strokeStyle = c.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(c.x - c.radius, c.y - c.radius/2 + Math.sin(c.x*0.1)*3);
                    ctx.quadraticCurveTo(c.x, c.y + Math.cos(c.x*0.1)*5, c.x + c.radius, c.y + c.radius/2 + Math.sin(c.x*0.1)*3);
                    ctx.stroke();
                }
            }
        ];

        class Player {
            constructor(x, y, radius, color) {
                this.x = x; this.y = y; this.baseY = y; this.radius = radius; this.color = color;
                this.velocityY = 0; this.gravity = 0.3; this.lift = -7;
                this.stageConfig = STAGES[currentStageIndex];
            }
            update() {
                this.velocityY += this.gravity; this.y += this.velocityY;
                if (this.y - this.radius < 0) { this.y = this.radius; this.velocityY = 0; }
                if (this.y + this.radius > gameHeight) { this.y = gameHeight - this.radius; this.velocityY = 0; }
            }
            draw() { this.stageConfig.playerRepresentation(this); }
            jump() {
                if (this.y + this.radius >= gameHeight - 5 || this.y - this.radius <= 5 || this.velocityY > -2) {
                     this.velocityY = this.lift;
                }
            }
            resetForStage(stageConfig) {
                this.stageConfig = stageConfig; this.radius = stageConfig.playerRadius;
                this.color = stageConfig.playerColor; this.y = gameHeight / 2; this.velocityY = 0;
            }
        }

        class Collectible {
            constructor(x, y, radius, color, value, speed) {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.value = value; this.speed = speed;
                this.stageConfig = STAGES[currentStageIndex];
            }
            update() { this.x -= this.speed; }
            draw() { this.stageConfig.collectibleRepresentation(this); }
        }

        function fullyResetGame() {
            cancelAnimationFrame(animationFrameId);
            isGameRunning = false;
            isInEndlessMode = false;
            currentStageIndex = 0;
            score = 0;
            stageProgress = 0;
            gameSpeed = 2;
            collectibles = [];
            obstacles = [];
            loadStage(0); // Ensure STAGES[0].name is used for display
            updateScoreDisplay();
            updateProgressBar();
            startScreen.style.display = 'flex';
            stageCompleteScreen.style.display = 'none';
        }


        function initGame() {
            resizeCanvas();
            currentStageIndex = 0;
            score = 0;
            gameSpeed = 2;
            isInEndlessMode = false; // Crucial reset
            player = new Player(gameWidth / 4, gameHeight / 2, STAGES[0].playerRadius, STAGES[0].playerColor);
            loadStage(currentStageIndex);
            startScreen.style.display = 'none';
            stageCompleteScreen.style.display = 'none';
            isGameRunning = true;
            gameLoop();
        }

        function loadStage(stageIndex) {
            currentStageIndex = stageIndex;
            const stage = STAGES[stageIndex];
            stageProgress = 0; // Reset progress for new stage
            collectibles = [];
            obstacles = [];
            
            if (player) {
                player.resetForStage(stage);
            } else {
                 player = new Player(gameWidth / 4, gameHeight / 2, stage.playerRadius, stage.playerColor);
            }

            // Ensure original stage name is used if coming from endless mode reset
            const originalStageName = STAGES[stageIndex].originalName || STAGES[stageIndex].name;
            stageNameDisplay.textContent = `Stage: ${originalStageName}`;
            if(STAGES[stageIndex].originalName) STAGES[stageIndex].name = originalStageName; // Restore it

            updateScoreDisplay();
            updateProgressBar();
            gameSpeed = 2 + stageIndex * 0.5; // Base speed for stage
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function updateProgressBar() {
            const stage = STAGES[currentStageIndex];
            let progressPercent = 0;
            if (isInEndlessMode && currentStageIndex === STAGES.length -1) {
                progressPercent = 100; // Bar stays full in endless mode for the final stage
            } else if (stage.goal > 0) {
                progressPercent = Math.min((stageProgress / stage.goal) * 100, 100);
            }
            progressBar.style.width = `${progressPercent}%`;
        }

        let frameCount = 0;
        function gameLoop() {
            if (!isGameRunning) return;

            frameCount++;
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            const currentStageData = STAGES[currentStageIndex];
            ctx.fillStyle = currentStageData.bgColor;
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            if (frameCount % currentStageData.itemSpawnRate === 0 && collectibles.length < 15) { // Limit max collectibles
                const y = Math.random() * (gameHeight - currentStageData.collectibleRadius * 2) + currentStageData.collectibleRadius;
                collectibles.push(new Collectible(
                    gameWidth, y,
                    currentStageData.collectibleRadius,
                    currentStageData.collectibleColor,
                    currentStageData.collectibleValue,
                    gameSpeed + Math.random() * 0.5 
                ));
            }

            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.update();
                collectible.draw();

                const dist = Math.hypot(player.x - collectible.x, player.y - collectible.y);
                if (dist < player.radius + collectible.radius) {
                    score += collectible.value;
                    if (!isInEndlessMode || currentStageIndex < STAGES.length -1) { // Don't add to stageProgress if in endless final stage
                        stageProgress += collectible.value;
                    }
                    playSound('collect');
                    updateScoreDisplay();
                    updateProgressBar();
                    collectibles.splice(i, 1); 

                    if (!isInEndlessMode && stageProgress >= currentStageData.goal) {
                        completeStage();
                        // return; // Don't return if it might go into endless immediately
                    }
                } else if (collectible.x + collectible.radius < 0) {
                    collectibles.splice(i, 1); 
                }
            }
            
            player.update();
            player.draw();

            if (isInEndlessMode) {
                gameSpeed += 0.0003; // Slower, more gradual increase for endless
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function completeStage() {
            playSound('stage_complete');

            if (currentStageIndex < STAGES.length - 1) { // If not the very last defined stage
                isGameRunning = false; // Pause game for stage transition
                cancelAnimationFrame(animationFrameId);
                stageCompleteTitle.textContent = `Stage ${STAGES[currentStageIndex].name} Complete!`;
                stageCompleteMessage.textContent = `Preparing for the ${STAGES[currentStageIndex + 1].name} stage.`;
                stageCompleteScreen.style.display = 'flex';
            } else { // This is the last defined stage, it now becomes truly endless
                isInEndlessMode = true;
                // Store original name if not already stored
                if (!STAGES[currentStageIndex].originalName) {
                    STAGES[currentStageIndex].originalName = STAGES[currentStageIndex].name;
                }
                STAGES[currentStageIndex].name = `${STAGES[currentStageIndex].originalName} (Endless)`;
                stageNameDisplay.textContent = `Stage: ${STAGES[currentStageIndex].name}`;
                stageProgress = STAGES[currentStageIndex].goal; // Mark as "complete" for progress bar
                updateProgressBar(); // Ensure bar is full
                // Game continues, gameLoop is not stopped. Speed will increase in gameLoop.
            }
        }

        function advanceToNextStage() {
            stageCompleteScreen.style.display = 'none';
            currentStageIndex++;
            // No need to check if currentStageIndex < STAGES.length here,
            // loadStage will handle it.
            loadStage(currentStageIndex);
            isGameRunning = true; // Resume game
            gameLoop();
        }

        function resizeCanvas() {
            const maxWidth = 800; const maxHeight = 600; const aspectRatio = 4 / 3;
            let newWidth = window.innerWidth * 0.9; let newHeight = window.innerHeight * 0.65;
            if (newWidth / newHeight > aspectRatio) { newWidth = newHeight * aspectRatio; } 
            else { newHeight = newWidth / aspectRatio; }
            newWidth = Math.min(newWidth, maxWidth); newHeight = Math.min(newHeight, maxHeight);
            canvas.width = newWidth; canvas.height = newHeight;
            gameWidth = canvas.width; gameHeight = canvas.height;
            if (player) { player.x = gameWidth / 4; }
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            if(isGameRunning) { updateProgressBar(); } // Redraw UI elements if needed
        });

        function handleInteractionStart(event) {
            if (isGameRunning && player) {
                event.preventDefault(); player.jump();
            }
        }
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });

        startButton.addEventListener('click', initGame);
        nextStageButton.addEventListener('click', advanceToNextStage);
        restartGameButton.addEventListener('click', fullyResetGame); // New restart button
        
        musicToggleButton.addEventListener('click', () => {
            musicOn = !musicOn;
            musicToggleButton.textContent = `Music: ${musicOn ? 'ON' : 'OFF'}`;
            console.log("Music toggled:", musicOn ? "ON" : "OFF", "(Music playback not implemented)");
        });

        sfxToggleButton.addEventListener('click', () => {
            if (!audioCtx) return;
            sfxOn = !sfxOn;
            sfxToggleButton.textContent = `SFX: ${sfxOn ? 'ON' : 'OFF'}`;
        });

        // Initial setup
        resizeCanvas();
        startScreen.style.display = 'flex';

    </script>
</body>
</html>
