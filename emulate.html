<!DOCTYPE html>
<html lang="hi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>VIRAT SWARUP - Cell to Cosmos</title> <!-- Combined title -->
    <!-- Font Awesome Icons -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      /* Reset & Base Styles */
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Georgia", serif;
      }

      body {
        background: #ffffff;
        color: #2c2c2c;
      }

      /* हैडर सेक्शन */
      .header {
        padding: 10px 10px 10px;
        text-align: center;
        border-bottom: 1px solid #e0e0e0;
        background-color: #8b0000;
      }
      .header h1 {
        font-size: 52px;
        letter-spacing: 3.2px;
        text-transform: uppercase;
        margin-bottom: 12px;
        color: white;
      }
      .header h2 {
        font-size: 22px;
        color: #fff;
        font-weight: 300;
      }

      /* हैमबर्गर मेन्यू */
      .hamburger {
        position: fixed;
        top: 25px;
        right: 25px;
        cursor: pointer;
        display: none;
        z-index: 1000;
      }
      .hamburger-line {
        width: 28px;
        height: 2px;
        background: #000000;
        margin: 6px 0;
        transition: 0.4s;
      }
      .hamburger.active .hamburger-line { /* For 'X' icon lines */
        background: #ffffff; /* White lines on active for contrast with menu */
      }
      .hamburger.active .hamburger-line:nth-child(1) {
        transform: rotate(-45deg) translate(-5px, 6px);
      }
      .hamburger.active .hamburger-line:nth-child(2) {
        opacity: 0;
      }
      .hamburger.active .hamburger-line:nth-child(3) {
        transform: rotate(45deg) translate(-5px, -6px);
      }


      /* मोबाइल मेन्यू */
      .mobile-menu {
        position: fixed;
        top: 0;
        right: -300px;
        width: 300px;
        height: 100%;
        background: #8b0000;
        box-shadow: -2px 0 15px rgba(0, 0, 0, 0.1);
        transition: 0.4s;
        padding-top: 80px;
        z-index: 999;
      }
      .mobile-menu.active {
        right: 0;
      }
      .mobile-menu a {
        display: flex;
        align-items: center;
        gap: 15px;
        padding: 18px 30px;
        color: #fff;
        text-decoration: none;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .mobile-menu i {
        width: 25px;
        font-size: 20px;
        color: #fff;
      }

      /* बॉटम नेविगेशन */
      .bottom-nav {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100%;
        background: #8b0000;
        border-top: 1px solid #eee;
        padding: 8px 0;
        display: none;
        z-index: 999;
      }
      .bottom-nav ul {
        display: flex;
        justify-content: space-around;
        list-style: none;
      }
      .bottom-nav a {
        color: #fff;
        font-size: 16px;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 10px 14px;
        border-radius: 8px;
        transition: background 0.3s;
      }

      .bottom-nav a:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }

      /* डेस्कटॉप नेविगेशन */
      .desktop-nav {
        margin: 45px 0;
        text-align: center; /* Center the ul */
      }
      .desktop-nav ul {
        display: inline-flex; /* Allows centering of the flex container itself */
        justify-content: center;
        gap: 32px;
        list-style: none;
      }
      .desktop-nav a {
        color: #8b0000;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 18px;
      }

      /* रिस्पॉन्सिव डिज़ाइन */
      @media (max-width: 768px) {
        .hamburger {
          display: block;
        }
        .desktop-nav {
          display: none;
        }
        .bottom-nav {
          display: block;
        }
        .header { /* This style will now apply */
          padding: 70px 20px 35px;
        }
        .header h1 { /* This style will now apply (unless overridden by inline) */
          font-size: 42px;
        }
      }
    </style>
    <style>
        /* Styles for EvoRun Game - Applied to gameAreaWrapper and its children */
        #gameAreaWrapper {
            font-family: Arial, sans-serif;
            /* background-color: #fff; /* Body background is already white */
            /* color: #fff; Game UI elements set their own colors, this could be a default for text within this wrapper */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center; /* Vertically centers the game block if there's space */
            padding: 20px 0; /* Some spacing around the game area */
            width: 100%;
        }

        #gameContainer {
            position: relative;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0, 200, 255, 0.5);
            /* overflow: hidden; /* To contain canvas if it ever tries to exceed bounds */
        }
        canvas {
            display: block;
            background-color: #000; /* Fallback, will be drawn over */
        }
        #uiOverlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none; /* Allow clicks to pass through to canvas */
            color: #fff; /* Explicitly set color for score/stage text */
        }
        #score, #stageName {
            font-size: 9px; /* Adjusted to be more readable perhaps */
            background-color: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 5px;
        }
        #progressBarContainer {
            width: 100%;
            max-width: 800px; /* Match max game width for consistency */
            box-sizing: border-box; /* Include padding/border in width */
            background-color: #ddd; /* Changed for better visibility */
            border-radius: 5px;
            overflow: hidden;
            height: 20px;
            margin: 10px 0;
            border: 1px solid #ccc; /* Changed for better visibility */
        }
        #progressBar {
            width: 0%;
            height: 100%;
            background-color: #8b0000;
            transition: width 0.3s ease-in-out;
        }
        #controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        button { /* Generic button style for game controls */
            padding: 10px 15px;
            font-size: 16px;
            background-color: #8b0000;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        button:hover {
            background-color: #a52a2a; /* Darken on hover slightly */
        }
        #startScreen, #stageCompleteScreen {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: rgba(0,0,0,0.85);
            color: #fff; /* Ensure text is white */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10; /* Above canvas, below mobile menu */
        }
        #startScreen h2, #stageCompleteScreen h2 { margin-top: 0; }
        #startScreen p, #stageCompleteScreen p { margin-bottom: 20px; }
    </style>
</head>
<body>
    <!-- हैमबर्गर आइकन -->
    <div class="hamburger" onclick="toggleMenu()">
      <div class="hamburger-line"></div>
      <div class="hamburger-line"></div>
      <div class="hamburger-line"></div>
    </div>

    <!-- मोबाइल मेन्यू -->
    <nav class="mobile-menu">
      <a href="#login"><i class="fas fa-sign-in-alt"></i>Login</a>
      <a href="#share"><i class="fas fa-share"></i>Share</a>
      <a href="index.html"><i class="fas fa-home"></i>Home</a>
      <a href="agnosia.html"><i class="fas fa-eye-slash"></i>Agnosia</a>
      <a href="enigma.html"><i class="fas fa-question-circle"></i>Enigma</a>
      <a href="emulate.html"><i class="fas fa-copy"></i>Emulate</a>
      <a href="index.html"><i class="fas fa-comment"></i>Post</a> <!-- Assuming index.html for Post -->
    </nav>

    <!-- हैडर -->
    <header class="header" style="background-color: #8b0000; padding: 10px 10px 10px; text-align: center;">
        <h1 style="color: white; font-size: 24px; margin: 0;">VIRAT SWARUP</h1> <!-- Corrected font-size -->
        <h2 style="color: white; font-size: 13px; margin: 0;"> The Supreme Devine of Every Faith</h2>
    </header>

    <!-- डेस्कटॉप नेविगेशन -->
    <nav class="desktop-nav">
      <ul>
        <li><a href="index.html"><i class="fas fa-home"></i>Home</a></li>
        <li><a href="agnosia.html"><i class="fas fa-eye-slash"></i>Agnosia</a></li> <!-- Corrected href -->
        <li><a href="enigma.html"><i class="fas fa-question-circle"></i>Enigma</a></li> <!-- Corrected href -->
        <li><a href="emulate.html"><i class="fas fa-copy"></i>Emulate</a></li> <!-- Corrected href -->
        <li><a href="index.html"><i class="fas fa-comment"></i>Post</a></li> <!-- Assuming index.html for Post -->
      </ul>
    </nav>

    <!-- बॉटम नेविगेशन (visible on mobile) -->
    <nav class="bottom-nav">
      <ul>
        <li><a href="index.html"><i class="fas fa-home"></i>Home</a></li>
        <li><a href="agnosia.html"><i class="fas fa-eye-slash"></i>Agnosia</a></li>
        <li><a href="enigma.html"><i class="fas fa-question-circle"></i>Enigma</a></li>
        <li><a href="emulate.html"><i class="fas fa-copy"></i>Emulate</a></li>
        <li><a href="index.html"><i class="fas fa-comment"></i>Post</a></li>
      </ul>
    </nav>
      
    <!-- Wrapper for Game Elements -->
    <div id="gameAreaWrapper">
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div id="uiOverlay">
                <div id="stageName">Cell</div>
                <div id="score">Score: 0</div>
            </div>
            <div id="startScreen">
                <h2>Cell to Cosmos</h2>     
                <p>The final stage is endless. Reach for the highest score!</p>
                <button id="startButton">Start Game</button>
            </div>
            <div id="stageCompleteScreen" style="display: none;">
                <h2 id="stageCompleteTitle">Stage Complete!</h2>
                <p id="stageCompleteMessage">Preparing for the next phase of evolution...</p>
                <button id="nextStageButton">Next Stage</button>
            </div>
        </div>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
        <div id="controls">
            <button id="musicToggle">Music: OFF</button>
            <button id="sfxToggle">SFX: ON</button>
            <button id="restartGameButton" title="Restart Game">Restart</button>
        </div>
    </div>

    <script>
        // Hamburger Menu Toggle Function
        function toggleMenu() {
          const mobileMenu = document.querySelector('.mobile-menu');
          const hamburger = document.querySelector('.hamburger');
          mobileMenu.classList.toggle('active');
          hamburger.classList.toggle('active');
        }

        // Game Script (EvoRun: Cell to Cosmos)
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const scoreDisplay = document.getElementById('score');
        const stageNameDisplay = document.getElementById('stageName');
        const progressBar = document.getElementById('progressBar');

        const startScreen = document.getElementById('startScreen');
        const stageCompleteScreen = document.getElementById('stageCompleteScreen');
        const stageCompleteTitle = document.getElementById('stageCompleteTitle');
        const stageCompleteMessage = document.getElementById('stageCompleteMessage');
        
        const startButton = document.getElementById('startButton');
        const nextStageButton = document.getElementById('nextStageButton');
        const restartGameButton = document.getElementById('restartGameButton');
        const musicToggleButton = document.getElementById('musicToggle');
        const sfxToggleButton = document.getElementById('sfxToggle');

        let gameWidth, gameHeight;
        let player;
        let collectibles = [];
        let obstacles = []; // Declared but not used in provided code, kept for consistency
        let score = 0;
        let currentStageIndex = 0;
        let stageProgress = 0;
        let gameSpeed = 2;
        let animationFrameId;
        let isGameRunning = false;
        // let isJumping = false; // Declared but not directly used for logic, jump mechanics don't rely on it
        let isInEndlessMode = false; 

        let sfxOn = true;
        let musicOn = false;

        let audioCtx;
        try {
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            console.warn("Web Audio API is not supported. SFX disabled.");
            sfxOn = false;
            sfxToggleButton.textContent = "SFX: N/A";
            sfxToggleButton.disabled = true;
        }

        function playSound(type = 'collect') {
            if (!sfxOn || !audioCtx) return;
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'collect') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.2);
            } else if (type === 'stage_complete') {
                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(261.63, audioCtx.currentTime); // C4
                gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.8);
            }
            oscillator.start();
            oscillator.stop(audioCtx.currentTime + (type === 'collect' ? 0.2 : 0.8));
        }
        
        const STAGES = [
            {
                name: "Cell",
                bgColor: "#001f3f", playerColor: "#7FDBFF", playerRadius: 15,
                collectibleColor: "#FFDC00", collectibleRadius: 8, collectibleValue: 10,
                goal: 100, itemSpawnRate: 100,
                playerRepresentation: (p) => {
                    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    const pulse = Math.sin(Date.now() * 0.01) * 2;
                    ctx.strokeStyle = `rgba(127, 219, 255, ${0.5 + Math.sin(Date.now() * 0.01)*0.5})`;
                    ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius + pulse, 0, Math.PI * 2); ctx.stroke();
                },
                collectibleRepresentation: (c) => {
                    ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill();
                }
            },
            {
                name: "Heart",
                bgColor: "#600000", playerColor: "#FF4136", playerRadius: 20,
                collectibleColor: "#FF851B", collectibleRadius: 10, collectibleValue: 15,
                goal: 150, itemSpawnRate: 80,
                playerRepresentation: (p) => {
                    ctx.fillStyle = p.color; const pulse = Math.sin(Date.now() * 0.02) * 5;
                    const w = (p.radius + pulse) * 2; const h = w * 0.9;
                    ctx.beginPath(); ctx.moveTo(p.x, p.y + h / 4);
                    ctx.bezierCurveTo(p.x, p.y, p.x - w / 2, p.y, p.x - w / 2, p.y + h / 4);
                    ctx.bezierCurveTo(p.x - w / 2, p.y + h / 2, p.x, p.y + h / 1.5, p.x, p.y + h);
                    ctx.bezierCurveTo(p.x, p.y + h / 1.5, p.x + w / 2, p.y + h / 2, p.x + w / 2, p.y + h / 4);
                    ctx.bezierCurveTo(p.x + w / 2, p.y, p.x, p.y, p.x, p.y + h / 4); ctx.fill();
                },
                collectibleRepresentation: (c) => {
                    ctx.fillStyle = c.color; const pulse = Math.sin(Date.now() * 0.015 + c.x) * 2;
                    ctx.beginPath(); ctx.arc(c.x, c.y, c.radius + pulse, 0, Math.PI * 2); ctx.fill();
                }
            },
            {
                name: "Earth",
                bgColor: "#003366", playerColor: "#3D9970", playerRadius: 25,
                collectibleColor: "#0074D9", collectibleRadius: 12, collectibleValue: 20,
                goal: 200, itemSpawnRate: 120,
                playerRepresentation: (p) => {
                    ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "#7FDBFF"; ctx.beginPath();
                    ctx.arc(p.x + p.radius*0.2, p.y - p.radius*0.3, p.radius*0.7, Math.PI*0.3, Math.PI*1.2); ctx.fill();
                    ctx.beginPath(); ctx.arc(p.x - p.radius*0.3, p.y + p.radius*0.1, p.radius*0.5, Math.PI*1.5, Math.PI*0.5); ctx.fill();
                },
                collectibleRepresentation: (c) => {
                    ctx.fillStyle = c.color; ctx.beginPath(); ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = "rgba(173, 216, 230, 0.5)"; ctx.beginPath();
                    ctx.moveTo(c.x + c.radius, c.y); ctx.lineTo(c.x + c.radius + 20, c.y - 5);
                    ctx.lineTo(c.x + c.radius + 20, c.y + 5); ctx.closePath(); ctx.fill();
                }
            },
            { 
                name: "Universe",
                bgColor: "#0c0014", 
                playerColor: "#f0f0f0", 
                playerRadius: 10, 
                collectibleColor: "#dda0dd", 
                collectibleRadius: 7,
                collectibleValue: 25,
                goal: 250, 
                itemSpawnRate: 90,
                playerRepresentation: (p) => { 
                    ctx.fillStyle = p.color;
                    const corePulse = Math.sin(Date.now() * 0.03) * (p.radius * 0.3);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * 0.7 + corePulse, 0, Math.PI * 2);
                    ctx.fill();
                    const glowPulse = Math.sin(Date.now() * 0.02) * 5;
                    const gradient = ctx.createRadialGradient(p.x, p.y, p.radius * 0.5, p.x, p.y, p.radius + glowPulse + 5);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + Math.sin(Date.now() * 0.025) * 0.2})`);
                    gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius + glowPulse + 5, 0, Math.PI * 2);
                    ctx.fill();
                },
                collectibleRepresentation: (c) => { 
                    ctx.strokeStyle = c.color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(c.x - c.radius, c.y - c.radius/2 + Math.sin(c.x*0.1)*3);
                    ctx.quadraticCurveTo(c.x, c.y + Math.cos(c.x*0.1)*5, c.x + c.radius, c.y + c.radius/2 + Math.sin(c.x*0.1)*3);
                    ctx.stroke();
                }
            }
        ];

        class Player {
            constructor(x, y, radius, color) {
                this.x = x; this.y = y; this.baseY = y; this.radius = radius; this.color = color;
                this.velocityY = 0; this.gravity = 0.3; this.lift = -7;
                this.stageConfig = STAGES[currentStageIndex];
            }
            update() {
                this.velocityY += this.gravity; this.y += this.velocityY;
                if (this.y - this.radius < 0) { this.y = this.radius; this.velocityY = 0; }
                if (this.y + this.radius > gameHeight) { this.y = gameHeight - this.radius; this.velocityY = 0; }
            }
            draw() { this.stageConfig.playerRepresentation(this); }
            jump() {
                if (this.y + this.radius >= gameHeight - 5 || this.y - this.radius <= 5 || this.velocityY > -2) {
                     this.velocityY = this.lift;
                }
            }
            resetForStage(stageConfig) {
                this.stageConfig = stageConfig; this.radius = stageConfig.playerRadius;
                this.color = stageConfig.playerColor; this.y = gameHeight / 2; this.velocityY = 0;
            }
        }

        class Collectible {
            constructor(x, y, radius, color, value, speed) {
                this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.value = value; this.speed = speed;
                this.stageConfig = STAGES[currentStageIndex];
            }
            update() { this.x -= this.speed; }
            draw() { this.stageConfig.collectibleRepresentation(this); }
        }

        function fullyResetGame() {
            cancelAnimationFrame(animationFrameId);
            isGameRunning = false;
            isInEndlessMode = false;
            currentStageIndex = 0;
            score = 0;
            stageProgress = 0;
            gameSpeed = 2;
            collectibles = [];
            // obstacles = []; // Already empty or reset
            loadStage(0); 
            updateScoreDisplay();
            updateProgressBar();
            startScreen.style.display = 'flex';
            stageCompleteScreen.style.display = 'none';
        }


        function initGame() {
            resizeCanvas(); // Ensure dimensions are set first
            currentStageIndex = 0;
            score = 0;
            gameSpeed = 2;
            isInEndlessMode = false; 
            // Player is initialized/reset in loadStage
            loadStage(currentStageIndex);
            startScreen.style.display = 'none';
            stageCompleteScreen.style.display = 'none';
            isGameRunning = true;
            gameLoop();
        }

        function loadStage(stageIndex) {
            currentStageIndex = stageIndex;
            const stage = STAGES[stageIndex];
            stageProgress = 0; 
            collectibles = [];
            // obstacles = [];

            if (player) {
                player.resetForStage(stage);
            } else {
                 player = new Player(gameWidth / 4, gameHeight / 2, stage.playerRadius, stage.playerColor);
            }

            const originalStageName = STAGES[stageIndex].originalName || STAGES[stageIndex].name;
            stageNameDisplay.textContent = `Stage: ${originalStageName}`;
            if(STAGES[stageIndex].originalName && STAGES[stageIndex].name !== originalStageName) {
                 STAGES[stageIndex].name = originalStageName; 
            }

            updateScoreDisplay();
            updateProgressBar();
            gameSpeed = 2 + stageIndex * 0.5; 
        }

        function updateScoreDisplay() {
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function updateProgressBar() {
            const stage = STAGES[currentStageIndex];
            let progressPercent = 0;
            if (isInEndlessMode && currentStageIndex === STAGES.length -1) {
                progressPercent = 100; 
            } else if (stage.goal > 0) {
                progressPercent = Math.min((stageProgress / stage.goal) * 100, 100);
            }
            progressBar.style.width = `${progressPercent}%`;
        }

        let frameCount = 0;
        function gameLoop() {
            if (!isGameRunning) return;

            frameCount++;
            ctx.clearRect(0, 0, gameWidth, gameHeight);

            const currentStageData = STAGES[currentStageIndex];
            ctx.fillStyle = currentStageData.bgColor;
            ctx.fillRect(0, 0, gameWidth, gameHeight);

            if (frameCount % currentStageData.itemSpawnRate === 0 && collectibles.length < 15) { 
                const y = Math.random() * (gameHeight - currentStageData.collectibleRadius * 2) + currentStageData.collectibleRadius;
                collectibles.push(new Collectible(
                    gameWidth, y,
                    currentStageData.collectibleRadius,
                    currentStageData.collectibleColor,
                    currentStageData.collectibleValue,
                    gameSpeed + Math.random() * 0.5 
                ));
            }

            for (let i = collectibles.length - 1; i >= 0; i--) {
                const collectible = collectibles[i];
                collectible.update();
                collectible.draw();

                const dist = Math.hypot(player.x - collectible.x, player.y - collectible.y);
                if (dist < player.radius + collectible.radius) {
                    score += collectible.value;
                    if (!isInEndlessMode || currentStageIndex < STAGES.length -1) { 
                        stageProgress += collectible.value;
                    }
                    playSound('collect');
                    updateScoreDisplay();
                    updateProgressBar();
                    collectibles.splice(i, 1); 

                    if (!isInEndlessMode && stageProgress >= currentStageData.goal) {
                        completeStage();
                    }
                } else if (collectible.x + collectible.radius < 0) {
                    collectibles.splice(i, 1); 
                }
            }
            
            player.update();
            player.draw();

            if (isInEndlessMode && currentStageIndex === STAGES.length - 1) { // Only increase speed if in endless mode on the FINAL stage
                gameSpeed += 0.0003; 
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        
        function completeStage() {
            playSound('stage_complete');

            if (currentStageIndex < STAGES.length - 1) { 
                isGameRunning = false; 
                cancelAnimationFrame(animationFrameId);
                stageCompleteTitle.textContent = `Stage ${STAGES[currentStageIndex].name} Complete!`;
                stageCompleteMessage.textContent = `Preparing for the ${STAGES[currentStageIndex + 1].name} stage.`;
                stageCompleteScreen.style.display = 'flex';
            } else { 
                isInEndlessMode = true;
                if (!STAGES[currentStageIndex].originalName) {
                    STAGES[currentStageIndex].originalName = STAGES[currentStageIndex].name;
                }
                STAGES[currentStageIndex].name = `${STAGES[currentStageIndex].originalName} (Endless)`;
                stageNameDisplay.textContent = `Stage: ${STAGES[currentStageIndex].name}`;
                stageProgress = STAGES[currentStageIndex].goal; 
                updateProgressBar(); 
            }
        }

        function advanceToNextStage() {
            stageCompleteScreen.style.display = 'none';
            currentStageIndex++;
            loadStage(currentStageIndex);
            isGameRunning = true; 
            gameLoop();
        }

        function resizeCanvas() {
            const gameArea = document.getElementById('gameAreaWrapper');
            const maxWidth = 800; 
            const maxHeight = 600; 
            const aspectRatio = 4 / 3;
            
            // Calculate available width for game based on parent, minus some padding perhaps
            let availableWidth = gameArea.clientWidth * 0.95; // Use 95% of wrapper width
            if (window.innerWidth < 768) availableWidth = gameArea.clientWidth * 0.9; // Smaller screens, use more width

            let newWidth = Math.min(availableWidth, maxWidth);
            let newHeight = newWidth / aspectRatio;

            if (newHeight > maxHeight) {
                newHeight = maxHeight;
                newWidth = newHeight * aspectRatio;
            }
            
            // Ensure it doesn't exceed window height significantly
            const windowHeightThreshold = window.innerHeight * 0.7;
            if (newHeight > windowHeightThreshold) {
                newHeight = windowHeightThreshold;
                newWidth = newHeight * aspectRatio;
            }


            canvas.width = newWidth; 
            canvas.height = newHeight;
            gameWidth = canvas.width; 
            gameHeight = canvas.height;

            // Make progress bar and controls responsive to canvas width
            const progressBarContainer = document.getElementById('progressBarContainer');
            const controlsDiv = document.getElementById('controls');
            if (progressBarContainer) progressBarContainer.style.width = `${newWidth}px`;
            if (controlsDiv) controlsDiv.style.width = `${newWidth}px`;


            if (player) { 
                player.x = gameWidth / 4;
                // If game is running, player's Y might need adjustment if height changed drastically
                if (isGameRunning) {
                     player.y = Math.max(player.radius, Math.min(player.y, gameHeight - player.radius));
                } else {
                    player.y = gameHeight / 2; // Reset to middle if game not running
                }
            }
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            if(isGameRunning) { 
                updateProgressBar(); 
                // Potentially redraw canvas or elements if not in gameLoop
                // but gameLoop will handle redraw if active
            } else if (player) { // If game not running (e.g. on start screen)
                // Clear and redraw player placeholder if needed, or simply update dimensions
                ctx.clearRect(0,0, gameWidth, gameHeight);
                const stage = STAGES[currentStageIndex];
                ctx.fillStyle = stage.bgColor;
                ctx.fillRect(0,0, gameWidth, gameHeight);
                if(startScreen.style.display === 'none' && stageCompleteScreen.style.display === 'none') {
                    player.draw(); // Redraw player if on canvas but not actively looping
                }
            }
        });

        function handleInteractionStart(event) {
            if (isGameRunning && player) {
                event.preventDefault(); player.jump();
            }
        }
        canvas.addEventListener('mousedown', handleInteractionStart);
        canvas.addEventListener('touchstart', handleInteractionStart, { passive: false });

        startButton.addEventListener('click', initGame);
        nextStageButton.addEventListener('click', advanceToNextStage);
        restartGameButton.addEventListener('click', fullyResetGame); 
        
        musicToggleButton.addEventListener('click', () => {
            musicOn = !musicOn;
            musicToggleButton.textContent = `Music: ${musicOn ? 'ON' : 'OFF'}`;
            console.log("Music toggled:", musicOn ? "ON" : "OFF", "(Music playback not implemented)");
        });

        sfxToggleButton.addEventListener('click', () => {
            if (!audioCtx) return;
            sfxOn = !sfxOn;
            sfxToggleButton.textContent = `SFX: ${sfxOn ? 'ON' : 'OFF'}`;
        });

        // Initial setup
        resizeCanvas(); // Call resize at start to set initial dimensions
        startScreen.style.display = 'flex';

    </script>
</body>
</html>
